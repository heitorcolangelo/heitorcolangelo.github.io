---
layout: post
title: Testes no Android com Espresso — parte 4
tag:
- software-testing
- espresso
- android
---

<h4>Mockando requisições para a API.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*99qTbnhUu3jQsGn3eWIgrA.png" /></figure><p>No <a href="https://medium.com/@heitorcolangelo/testes-no-android-com-espresso-parte-3-b1d690e7bcc8#.qe0z1klwn">post anterior</a> aprendemos como mockar as intents do Android. Caso queira iniciar a partir deste post, utilize o branch ‘<a href="https://github.com/heitorcolangelo/EspressoTests/tree/part_2">part_</a>3’ do projeto.</p><h4>Cenários da MainActivity</h4><p>A MainActivity possui a lista com os usuários que recebemos da API. Caso ocorra um erro na requisição, a MainActivity exibirá uma tela com um erro ao invés da lista, e enquanto nenhuma resposta volta da API, um loading permanece na tela. Então, a princípio, temos três cenários para testar:</p><ol><li>Quando a requisição é feita com sucesso, devemos ver a lista com os usuários;</li><li>Quando houver um erro na requisição, devemos ver a tela de erro;</li><li>Quando não recebemos nenhuma resposta da API, devemos ver a tela de loading.</li></ol><p>Ótimo, levantamos os primeiros estados para testarmos nossa activity. Porém, temos um problema com o terceiro cenário.</p><p>Nos testes que fizemos até aqui, o Espresso fez várias interações com o nosso app mas, já parou para pensar como o Espresso sabe a hora que pode interagir com o app? Afinal de contas, os apps possuem animações e em muitos casos a UI só pode ser utilizada quando a animação acaba. Pois é, o espresso faz exatamente isso, ele espera a <a href="http://stackoverflow.com/questions/3652560/what-is-the-android-uithread-ui-thread">UI Thread</a> da aplicação ficar ociosa — em inglês, <em>idle.</em> Enquanto a UI não termina as animações, o Espresso não interage com ela. Se o app não ficar <em>idle</em> em 60 segundos, o Espresso devolve um erro:</p><pre>AppNotIdleException: Looped for 3544 iterations over 60 SECONDS. The following Idle Conditions failed .</pre><p>Sabendo disso, você já consegue imaginar que o teste do terceiro cenário não vai funcionar, pois como a tela de loading é uma animação infinita, a <em>UI Thread</em> nunca vai ficar <em>idle</em> e o Espresso nunca vai interagir com ela. Então, vamos eliminar este cenário com esta <strong>dica muito importante e que vai te poupar muita dor de cabeça</strong>:</p><blockquote><strong>Cuidado com animações de ‘loading’ na tela. Se elas estiverem na tela, o seu teste com certeza irá falhar.</strong></blockquote><h4>Escrevendo os testes</h4><p>Vamos criar nossos testes para atender os dois primeiros cenários. Vou deixar a configuração inicial da classe MainActivityTest por sua conta; ela é idêntica a configuração inicial da LoginActivityTest, a única diferença é no último parâmetro para criar a ActivityTestRule. Na LoginActivityTest usamos <em>true,</em> nesta iremos usar <em>false.</em> Lembra pra que serve este parâmetro? Ele indica se a activity deve ser iniciada automaticamente.</p><p>Ao final desta configuração, sua classe deve estar desta maneira:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fa186128ffed5e0cf28dc8ffadfa7167/href">https://medium.com/media/fa186128ffed5e0cf28dc8ffadfa7167/href</a></iframe><p>Ok, poderíamos simplesmente sair escrevendo os testes da mesma maneira que fizemos na LoginActivityTest. Porém, como esta activity faz uma requisição para a API logo que é iniciada, dependemos do resultado da requisição para que o teste dê certo ou não. Isso é ruim, como eu havia dito, devemos manter nossos testes isolados. Vamos então isolar nosso teste mockando o resultado da requisição que o app faz para a API. Para isso, vamos utilizar a lib <a href="https://github.com/square/okhttp/tree/master/mockwebserver">MockWebServer</a>.</p><h4>Configurando MockWebServer</h4><p>Adicione a seguinte dependência no seu arquivo build.gradle:</p><pre>androidTestCompile &quot;com.squareup.okhttp3:mockwebserver:$okHttpVersion&quot;</pre><p>Sincronize o projeto e vamos configurar o MockWebServer na nossa MainActivityTest. Dê uma olhada na implementação abaixo:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c0f81d9fc9c77ff35f4d49c4c72d9aec/href">https://medium.com/media/c0f81d9fc9c77ff35f4d49c4c72d9aec/href</a></iframe><p>Declaramos dois novos métodos: <em>setUp</em> e <em>tearDown. </em>Anotamos estes métodos com <em>Before </em>e <em>After</em>, respectivamente. Os métodos anotados com <em>Before</em> serão executados antes da activity ser iniciada. Os métodos anotados com <em>After</em>, serão executados ao final de cada teste. Fora isso, nada de muito especial, estamos apenas criando uma nova instância de MockWebServer e dando um start no server.</p><p>Porém, nosso app ainda está apontando para a url real da API, ou seja:</p><pre>http://api.randomuser.me/</pre><p>Isso significa que, se escrevermos um teste, nosso app ainda irá fazer a requisição para a API real, e não para nosso MockWebServer. Porém, pela nossa implementação, a url é definida como uma variável no nosso arquivo build.gradle, o que torna essa redefinição de URL um pouco mais difícil. Para facilitar nossa vida, vamos usar a lib <a href="http://projetos.vidageek.net/mirror-pt/mirror/">Mirror</a>.</p><p><strong>Importante:</strong> antes de continuar, revise como o app está fazendo as requisições para a API. Isso vai te ajudar a entender o que vamos fazer daqui pra frente.</p><p>Adicione esta dependência no seu arquivo build.gradle:</p><pre>androidTestCompile &quot;net.vidageek:mirror:1.6.1&quot;</pre><p>Agora vamos criar os métodos para alterar a url da nossa classe UsersApi, vou mostrar o código e explicar linha a linha.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/79304d64e73c668ae2d5f6a0fa475d91/href">https://medium.com/media/79304d64e73c668ae2d5f6a0fa475d91/href</a></iframe><p>Na linha 13, chamamos o método <em>setupServerUrl().</em> Vamos analisá-lo:</p><ul><li>Linha 22: definimos a url do nosso MockWebServer para “/”, pegamos o valor total da url e armazenamos na string <em>url;</em></li><li>Linha 24 e 25: apenas definimos o nível de log do nosso objeto <a href="https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor">HttpLogginInterceptor</a>;</li><li>Linha 27: criamos um objeto <a href="http://square.github.io/okhttp/">OkHttpClient</a> e passamos o nosso interceptor;</li><li>Linha 29: referenciamos a instância de UsersApi;</li><li>Linha 31: criamos um novo objeto Api com o retrofit, só que desta vez passando a url do nosso MockWebServer;</li><li>Linha 38: chamamos o método setField, que recebe como parâmetros:<br>1- O <em>target</em>, que é o objeto que terá o field alterado usando reflection com o mirror;<br>2- O nome do field que será alterado;<br>3- O novo valor que será atribuído ao field alterado.</li></ul><p>O método setField é onde de fato usaremos a lib Mirror. Acredito que seja bem simples entender o que ele faz, basicamente estamos falando para o Mirror pegar o field “api” do nosso target(que é um objeto da classe UsersApi) e alterar o valor deste field para o objeto que passamos no parâmetro value. Deste modo, estamos alterando a url base do nosso projeto para apontar para o nosso MockWebServer.</p><p>É importante ressaltar que, se sua implementação te permitir definir a url do endpoint de maneira mais simples, é bem provável que você não precise usar <em>reflection</em>.</p><p>Se você ficou com alguma dúvida, retome os passos anteriores antes de prosseguir; se, mesmo assim, estiver com dúvida, deixe nos comentários para que eu possa ajudar.</p><p>Agora nosso teste está isolando nosso app das chamadas da API. Porém, ainda não definimos a resposta que nosso MockWebServer irá retornar para cada caso de teste.</p><h4>Mockando o retorno da request</h4><p>Para podermos mockar o retorno, devemos ter um mock do objeto json igual ao que a API retorna. Isso é simples, basta simularmos uma requisição para a API no nosso navegador, por exemplo:</p><pre><a href="http://api.randomuser.me/?results=20">http://api.randomuser.me/?results=20</a></pre><p>Então, é só você copiar o json que aparecer no navegador e colocar em uma <em>string</em> em um lugar acessível aos testes. Eu costumo colocar em uma interface, conforme fiz no arquivo Mocks.java.</p><p>Agora vamos escrever nosso primeiro teste para a MainActivity. Neste teste iremos verificar se, quando a API retorna com sucesso os usuários, nós visualizamos a lista de usuários na tela.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f115603425e5d59619fb33550eb232e9/href">https://medium.com/media/f115603425e5d59619fb33550eb232e9/href</a></iframe><p>Linha 3: estamos chamando o método <em>enqueue</em> do MockWebServer. Este método vai enfileirar (<em>enqueue</em>, em inglês) o objeto <a href="https://github.com/square/okhttp/blob/master/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java">MockResponse</a> que passamos como parâmetro. Estamos definindo o <em>responseCode</em> como 200, ou seja, uma requisição com sucesso. Também estamos definindo o <em>body</em> com o mock que acabamos de copiar e colocamos na interface Mocks.java. Resumindo: estamos dizendo para o MockWebServer: “Quando chegar uma requisição para você, retorne este MockResponse” ;</p><p>Linha 4: iniciamos a activity, passamos uma intent simples, uma vez que não é necessário nenhum extra nesta activity;</p><p>Linha 5: estamos verificando se nossa lista está visível.</p><p>Rode o teste, ele deve passar. Agora veja como ficou o log:</p><pre>D/OkHttp: --&gt; GET <a href="http://localhost:41183/?page=0&amp;results=20">http://localhost:41183/?page=0&amp;results=20</a> http/1.1<br>D/OkHttp: --&gt; END GET<br>D/OkHttp: &lt;-- 200 OK <a href="http://localhost:41183/?page=0&amp;results=20">http://localhost:41183/?page=0&amp;results=20</a> (34ms)</pre><p>Veja que agora nosso endpoint é o <em>localhost</em>, ou seja, o MockWebServer.</p><p>Conseguimos testar um cenário da nossa activity de maneira isolada. Mas ainda falta outro cenário, aquele que quando uma requisição falha (código entre 400 e 500), aparece a tela de erro. Vou deixar esse teste para você implementar. Ele é bem simples, você apenas terá que mudar o código de retorno e o body.</p><p>Se algo deu errado, retome os passos anteriores ou deixe um comentário abaixo para eu poder te ajudar. Ao final desta etapa (após ter implementado o segundo cenário de teste) seu código deve estar parecido com o da branch ‘part_4’.</p><p>Se tiver alguma dúvida, sugestão, ou se encontrou um erro no post, deixe um comentário.</p><p>Ainda precisamos testar se o layout que definimos para o nosso item da recycler view está sendo apresentado corretamente. Também precisamos verificar se ao clicar em um item, enviamos as informações corretas para a activity de detalhes. Estes serão nossos próximos cenários de teste.</p><p><a href="https://medium.com/@heitorcolangelo/testes-no-android-com-espresso-parte-5-9df6dade067e#.vw2lakfmg">Ir para Parte 5— asserções e interações na recycler view &gt;&gt;</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6107e3e023bc" width="1" height="1" alt="">
