---
layout: post
title: Testes no Android com Espresso — Parte 2
tag:
- testing
- android
- espresso
---

<h4>Asserções simples e interações com views.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*99qTbnhUu3jQsGn3eWIgrA.png" /></figure><p>Na <a href="https://medium.com/@heitorcolangelo/testes-no-android-com-espresso-parte-1-8d739672a235#.r5toy52vk">parte 1</a> nós vimos como configurar nosso projeto. Se você quiser começar a partir desta parte, clone o projeto <a href="https://github.com/heitorcolangelo/EspressoTests">EspressoTests</a> no github e faça um fork da branch ‘part_1’, que representa o estado do projeto ao final da parte 1.</p><p><strong>Criando o primeiro teste</strong></p><p>Vamos começar testando a tela de login. Para isso, crie uma classe ‘<em>LoginActivityTest</em>’ no diretório ‘<em>/app/src/androidTest/’ </em>do projeto, conforme a imagem abaixo:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/462/1*DiqC06BAa2stAKtKtJ4TUw.png" /></figure><p>Anote a classe que criamos com a anotação:</p><pre>@RunWith(AndroidJUnit4.class)</pre><p>Isso irá indicar que esta classe deve ser executada com o AndroidJUnitRunner; se quiser saber mais sobre ele, acesse o <a href="https://developer.android.com/reference/android/support/test/runner/AndroidJUnitRunner.html">link</a>.</p><p>Agora, vamos definir nossa <a href="https://developer.android.com/reference/android/support/test/rule/ActivityTestRule.html">ActivityTestRule</a> com a activity que será iniciada antes de todos os nossos testes, ou seja, a activity que queremos testar.</p><pre>@Rule<br>public ActivityTestRule&lt;LoginActivity&gt;<br>    mActivityRule = new ActivityTestRule&lt;&gt;(LoginActivity.class, false, true);</pre><p>Os parâmetros do construtor são:</p><ul><li>A activity que será testada (LoginActivity.class),</li><li><a href="http://android-developers.blogspot.com.br/2008/12/touch-mode.html">initialTouchMode</a> (false),</li><li>Se deve iniciar automaticamente ou não (true).</li></ul><p>Seu código deve estar desta maneira:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6f234e934875e2e8ba5f68356903f0f7/href">https://medium.com/media/6f234e934875e2e8ba5f68356903f0f7/href</a></iframe><p><strong>Escrevendo o primeiro teste</strong></p><p>Agora vamos escrever nosso primeiro teste. Devemos testar os diferentes estados que a tela em questão pode assumir. Por exemplo, assim que iniciamos a LoginActivity, ela exibe uma imagem, dois campos de texto e um botão. Este pode ser considerado o estado inicial da tela. Vamos escrever um teste para verificar esse estado.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/77b11910ead7c68b8ca3d32bda3b3c62/href">https://medium.com/media/77b11910ead7c68b8ca3d32bda3b3c62/href</a></iframe><p>Uma das vantagens do Espresso é que a sintaxe é bem intuitiva. Praticamente podemos ler em linguagem natural o que o teste está executando. Vamos analisar a primeira linha do teste:</p><pre><em>onView</em>(<em>withId</em>(R.id.<em>login_image</em>)).check(<em>matches</em>(<em>isDisplayed</em>()));</pre><p>Poderíamos ler esta linha em linguagem natural, por exemplo: “<em>Verifique que a view com id login_image está visível na tela”</em>. Agora, explicando um pouco o que está acontecendo:</p><ul><li>onView() vai receber o ViewMatchers que passarmos como parâmetro e irá nos retornar um objeto ViewInteraction. Em outras palavras, estamos passando pra ele a view que queremos interagir;</li><li>withId() vai receber o id da view e irá nos retornar um ViewMatchers;</li><li>check() vai receber um ViewAssertion. Ou seja, vai verificar se é válida a asserção que estamos passando como parâmetro;</li><li>matches() vai receber um ViewMatchers e retornar um ViewAssertion;</li><li>isDisplayed() é o ViewMatchers que utilizaremos.</li></ul><p>Para saber mais sobre os objetos, clique nos links sobre <a href="https://developer.android.com/reference/android/support/test/espresso/matcher/ViewMatchers.html">ViewMatchers</a>, <a href="https://developer.android.com/reference/android/support/test/espresso/ViewInteraction.html">ViewInteraction</a> e <a href="https://developer.android.com/reference/android/support/test/espresso/ViewAssertion.html">ViewAssertion</a>.</p><p><strong>Executando o teste</strong></p><p>Agora é só executar o teste certo? Errado! Precisamos desativar as animações nas opções de desenvolvedor do nosso emulador/device. Para fazer isso, vá em <em>Configurações &gt; Programador (ou opções de desenvolvedor)</em> e desative estas três opções:</p><ul><li>Animação em escala;</li><li>Escala de transição;</li><li>Escala de duração da animação.</li></ul><p>O Espresso aguarda a UI Thread ficar ociosa (idle) para executar o próximo passo do teste. Porém, se as animações estiverem ligadas, ele irá se perder e os testes irão quebrar, leia mais sobre isso <a href="https://google.github.io/android-testing-support-library/docs/espresso/setup/index.html">aqui</a>.</p><p>Agora, para rodar este teste, basta clicar no botão direito do mouse sobre o método e depois clicar na opção <em>Run ‘whenActivityIsLaunched…’</em>. Se tudo correr bem, você deve ver o teste ser executado no seu emulador e o console de testes estará assim:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*FdQm1REF0c1wfQ5XTm6s4Q.png" /></figure><p>Certo, mas como eu garanto que o Espresso está realmente funcionando e olhando se minhas views estão aparecendo na tela? Para garantir isso, vamos alterar a primeira linha deste teste que fizemos:</p><pre>onView(<em>withId</em>(R.id.<em>login_image</em>)).check(<em>matches</em>(<strong><em>not</em>(</strong><em>isDisplayed</em>()<strong>)</strong>));</pre><p>O método <em>not() </em>irá inverter o resultado que esperávamos. Então, estou dizendo neste teste que a view com id <em>login_image</em> <strong>não </strong>estará visível na tela, o que não é verdade, pois ao iniciar a tela, a imagem estará visível. Então o teste deve obrigatoriamente falhar. Se rodarmos o teste novamente:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*80B6EEH6aQ23BKFehl6AFA.png" /></figure><p>Ótimo, nosso teste falhou, o que significa que o Espresso está fazendo as asserções corretamente. Melhor que isso, repare no log que ele mostra:</p><pre>Expected: not is displayed on the screen to the user<br>Got: AppCompatImageView{..., visibility=VISIBLE, ...}</pre><p>Ou seja, ele também nos mostra onde o teste está falhando. Agora podemos remover o método <em>not()</em> que adicionamos e rodar esse teste novamente. Deu verde? Então vamos em frente.</p><p>Este teste foi fácil, o que devemos fazer agora é testar os outros estados da tela. Um destes outros estados é quando deixamos um dos campos de texto em branco, e clicamos no botão de login. Quando isso acontece, o app exibe um dialog na tela. Vamos escrever um teste para verificar esse estado.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/838bb3329305b69e42ffb190b232079d/href">https://medium.com/media/838bb3329305b69e42ffb190b232079d/href</a></iframe><p><strong>Não execute o teste ainda</strong>, ele não vai funcionar, mas por outro motivo que vou abordar mais pra frente. Primeiro, vamos somente analisar o código. Utilizamos três novos métodos:</p><ul><li>perform(): vai executar a ViewAction que receber como parâmetro;</li><li>typeText(): ViewAction para digitar um texto na view;</li><li>click(): ViewAction para clicar na view;</li><li>withText(): vai procurar a view que contenha o texto passado como parâmetro.</li></ul><p>O primeiro bloco do nosso teste está executando as seguintes ações:</p><ul><li>Escrevendo um texto no campo <em>login_username;</em></li><li>Clicando no botão de login;</li><li>Verificando que o dialog está aparecendo (pois deixamos o campo senha em branco);</li><li>Clicando no <em>Ok </em>do dialog para fechá-lo.</li></ul><p>O segundo bloco faz basicamente a mesma coisa que o primeiro bloco, só que com o campo <em>login_password. A </em>única diferença é que ele limpa o campo <em>login_username </em>antes, pois o campo está preenchido por causa do bloco anterior. Isso não é muito legal, ter que limpar o que os passos anteriores do teste fizeram para executar os próximos passos. Nossos testes devem validar os cenários de maneira isolada. Então, vamos refatorar este código.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5c43b9d86baf4bfe991730610f49f928/href">https://medium.com/media/5c43b9d86baf4bfe991730610f49f928/href</a></iframe><p>Ótimo, agora temos dois testes, e um não está influenciando no outro. Porém ainda repetimos os mesmos passos para ambos os testes. Acho que podemos refatorá-los novamente.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/87b82756360ebc3601fd6b74e28b9cb1/href">https://medium.com/media/87b82756360ebc3601fd6b74e28b9cb1/href</a></iframe><p>Agora está melhor, temos um código mais limpo e reutilizável. Este é um bom momento para eu dar a primeira dica desta série:</p><blockquote><strong>Faça testes pequenos, não faça testes longos.</strong></blockquote><p>Evite fazer testes que executem várias coisas, foque em cenários pequenos e, de preferência, independentes.</p><p>Agora sim, tente rodar os testes. Como eu já havia dito antes, eles falham. Vamos analisar o log:</p><pre>Error performing &#39;single click - At Coordinates: ... <strong>on view &#39;with id: com.example.heitorcolangelo.espressotests:id/login_button&#39;.</strong></pre><p>Aparentemente o Espresso não conseguiu efetuar o click no botão de login, ou seja, o problema está na segunda linha do método <em>testEmptyFieldState:</em></p><pre>onView(withId(R.id.login_button)).perform(click());</pre><p>Coloque um <em>breakpoint </em>nesta linha e vamos ver a tela do emulador neste momento:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/368/1*2_cNXc7l-2_qZZrHvZRy4w.png" /></figure><p>Repare que o teclado virtual está ocupando uma boa parte da tela, inclusive ele está cobrindo o nosso botão de login, por isso o Espresso não pode clicar no botão. Para corrigir este problema vamos utilizar o método <em>closeSoftKeyboard().</em></p><pre>onView(<em>withId</em>(notEmptyFieldId)).perform(<em>typeText</em>(&quot;defaultText&quot;),<br><strong><em>closeSoftKeyboard</em>()</strong>);</pre><p>Este método irá fechar o teclado virtual após digitarmos o texto “defaultText”. Nosso botão de login ficará visível e o Espresso conseguirá clicar nele. Rode o teste novamente, acredito que agora irá passar.</p><p>Aí vai a segunda dica:</p><blockquote><strong>Sempre que tiver um teste que envolva digitar texto em um EditText, não se esqueça de usar o método closeSoftKeyboard() para esconder o teclado virtual.</strong></blockquote><p>Se você deixar o teclado virtual aberto durante os testes, ele vai ficar por cima de views que poder ser essenciais para seu teste, e este irá falhar.</p><p>Ufa, bastante coisa até aqui, mas ainda temos dois cenários para validar:</p><ol><li>Quando os dois campos estão vazios, deve exibir o dialog;</li><li>Quando os dois campos são preenchidos, deve abrir a MainActivity.</li></ol><p>O cenário 1 vou deixar como exercício para você resolver. O cenário 2 envolve outro conceito que vou deixar para o próximo post.</p><p>Ao final desta etapa, o seu código deve estar parecido com o branch ‘<a href="https://github.com/heitorcolangelo/EspressoTests/tree/part_2">part_2</a>’.</p><p>Se tiver dúvidas, sugestões ou encontrou alguma informação errada neste post, deixe um comentário abaixo.</p><p><a href="https://medium.com/@heitorcolangelo/testes-no-android-com-espresso-parte-3-b1d690e7bcc8#.qe0z1klwn">Ir para parte 3 — testando intents &gt;&gt;</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5180ee03ed9a" width="1" height="1" alt="">
