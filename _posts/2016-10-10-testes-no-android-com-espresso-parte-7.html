---
layout: post
title: Testes no Android com Espresso — parte 7
tag:
- android
- espresso
- teste
- test
---

<h4>Dicas finais, TestButler e Robots Pattern.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*99qTbnhUu3jQsGn3eWIgrA.png" /></figure><p>No <a href="https://medium.com/concrete-solutions/testes-no-android-com-espresso-parte-6-d53984b24dbb#.vl2rf93bz">post anterior</a> aprendemos como criar <em>custom matchers</em> e como tratar <em>run time permissions</em> com UiAutomator. Nesta última parte vou focar mais em algumas dicas que acho importante, também vou falar sobre TestButler e Robots Pattern. Para acompanhar esta parte, utilize o branch ‘<a href="https://github.com/heitorcolangelo/EspressoTests/tree/part_7">part_7</a>’ do projeto.</p><h4>Animações de Loading x AlertDialogs</h4><p>Cuidado com animações que mostram progresso (<em>loadings</em>), especialmente se um dialog estiver por cima desta animação. Quando o dialog está por cima do loading, a animação ainda está acontecendo na UiThread. Ou seja, o estado <em>idle,</em> que o Espresso fica esperando para poder seguir com o teste, nunca acontece. Alterei a LoginActivity para poder demonstrar isso, repare como ficou o método de click do botão de login. Desconsidere o layout e a funcionalidade desta alteração, a ideia é apenas demonstrar o problema em questão.</p><pre>loginButton.setOnClickListener(new View.OnClickListener() {<br>  @Override<br>  public void onClick(View v) {<br>    <strong>showLoading();</strong><br>    if (validateFields())<br>      doLogin();<br>    else<br>      showErrorDialog();<br>  }<br>});</pre><p>Com essa alteração, toda vez que o usuário clicar no botão de login, o loading é exibido na tela e, depois disso, fazemos o processo de login. O problema é que, quando os campos estão vazios, o dialog de erro é exibido, e isso nos coloca exatamente na situação que mencionei anteriormente, um dialog em cima de um loading. Rode os testes da LoginActivity e repare que os testes que envolvem o dialog de erro quebram.</p><pre><strong>AppNotIdleException</strong>: Looped for 3608 iterations over 60 SECONDS. The following Idle Conditions failed.</pre><p>Portanto, sempre esconda os seus <em>loadings</em> da tela antes de exibir um dialog para o usuário, e sempre que um teste estiver falhando por conta de uma <strong>AppNotIdleException, </strong>verifique se não existe um loading “escondido” na sua tela.</p><h4>Teste o comportamento.</h4><p>Foque em testar o comportamento do app, não fique testando propriedades de layout. Se realmente precisar verificar as posições, use <em>position assertions</em>:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/347/1*_YqXV5KcOhZJAYYWVvZKXQ.png" /><figcaption>Position assertions from <a href="https://google.github.io/android-testing-support-library/downloads/espresso-cheat-sheet-2.1.0.pdf">espresso-cheat-sheet</a>.</figcaption></figure><h4>Execute seus testes em devices pequenos.</h4><p>Enquanto você roda seus testes em devices de tela grande, tudo ocorre muito bem, nada quebra. Mas não se esqueça que tem muita gente com dispositivos pequenos por aí, e que irão querer usar o seu app. Então seja bonzinho, lembre-se destas pessoas e execute seus testes em devices pequenos. Você vai perceber que muitos vão falhar, principalmente por conta de views que não estão na tela.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/239/1*2RwUM2Kl7JDj66RmE2-8_Q.png" /><figcaption>Em um dispositivo pequeno, o endereço do usuário não fica visível. O teste quebra.</figcaption></figure><p>Você vai ter que usar bastante o método <em>scrollTo().</em></p><h4>Ação de toque único em devices/emuladores lentos (antigos).</h4><p>No Google I/O deste ano, mais especificamente <a href="https://www.youtube.com/watch?v=isihPOY2vS4&amp;list=WL&amp;index=5">nesta palestra</a>, foi apresentada uma informação importantíssima que é um problema de interpretação de toques únicos feitos pelo Espresso. Eles não entraram em detalhes, mas disseram que, em algumas vezes, o toque único é interpretado como um toque longo (long click) em dispositivos ou emuladores lentos. Isto acontece pois o toque em si é composto de duas ações: pressionar e soltar. Quando o dispositivo é muito antigo e lento, e tem alguma tarefa rodando em background, o tempo de resposta entre um evento e outro pode demorar, então este toque é interpretado como um <em>long click. </em>Para evitar que isto acabe quebrando seus testes, altere a seguinte configuração:</p><pre>Settings -&gt; Accessibility -&gt; Touch and hold delay -&gt; LONG</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/240/1*kv2M-P40FmQImu6S10o7Dw.png" /><figcaption>Mude a propriedade destacada para LONG.</figcaption></figure><h4>O toast do Leak Canary.</h4><p><a href="https://github.com/square/leakcanary">Leak Canary</a> é uma lib para detectar leaks de memória no seu app. É uma ótima lib porém, de vez em quando, ela lança automaticamente um toast na tela e, se isso acontecer durante a execução dos seus testes, eles vão quebrar, pois o toast vai bloquear a UI e o Espresso pode não encontrar a view com a qual ele está tentando interagir. Então, não instale o Leak Canary no device e/ou emulador que utilizará para fazer os testes.</p><h4>TestButler, “descontaminando” o dispositivo para os testes.</h4><p>Enquanto eu escrevia esta série de posts, o Linkedin lançou uma lib chamada <a href="https://github.com/linkedin/test-butler">TestButler</a>. Ela estabiliza o emulador em que os testes estão rodando, evitando que estes testes falhem por problemas nele. Por exemplo, você já deve ter se deparado com essa situação:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/289/1*-Jyyt2Wmq6sbTDXJPwguUA.png" /><figcaption>Isso não é legal =(</figcaption></figure><p>Isso com certeza quebrará seu teste. A ideia do TestButler é evitar que isso ocorra. Além disso, você também consegue alterar algumas configurações globais do emulador, como:</p><ul><li>Habilitar/Desabilitar WiFi;</li><li>Mudar orientação do dispositivo;</li><li>Definir o modo do location service (Alta precisão ou economia de energia);</li><li>Definir o Locale (língua padrão) da aplicação, caso seu app seja destinado a mais de um país isso vai te ajudar bastante.</li></ul><p>Enfim, vale a pena estudar e usar esta lib, com certeza vai ajudar bastante.</p><p><a href="https://github.com/linkedin/test-butler">linkedin/test-butler</a></p><h4>Robots Pattern</h4><p>Semana passada assisti um tech talk na <a href="https://medium.com/u/a791b2313cef">Concrete Solutions</a> sobre <a href="https://realm.io/news/kau-jake-wharton-testing-robots/">Robots Pattern</a>. Este padrão, apresentado por Jake Wharton, tem o objetivo de deixar os testes mais estáveis, legíveis e fáceis de dar manutenção. Por exemplo, um dos nossos testes da LoginActivity está desta forma:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e4f6cc8cc20a00dee0c426d6e14d4223/href">https://medium.com/media/e4f6cc8cc20a00dee0c426d6e14d4223/href</a></iframe><p>Aplicando Robots, o mesmo teste ficaria assim:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2abee0cda0e3189863993e20935f6491/href">https://medium.com/media/2abee0cda0e3189863993e20935f6491/href</a></iframe><p>O código fica mais legível e você deixa na classe de testes somente os passos do teste em si. A maneira como estes passos serão implementados fica separado em outras classes:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0af27b5fb2f37f72739f3ee498b92d25/href">https://medium.com/media/0af27b5fb2f37f72739f3ee498b92d25/href</a></iframe><p>Na palestra, Jake Wharton implementa Robots com <a href="https://kotlinlang.org/">Kotlin</a>. Se usarmos o Kotlin, nosso teste ficaria bem mais limpo, por exemplo:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e6f51bb63872461e91a095dd26a0ef92/href">https://medium.com/media/e6f51bb63872461e91a095dd26a0ef92/href</a></iframe><p>Bem legal né? E isso é só o começo, dá pra brincar bastante e melhorar a maneira como testamos nossos apps com este padrão. Assista a palestra toda, vale muito a pena.</p><p><a href="https://realm.io/news/kau-jake-wharton-testing-robots/">Instrumentation Testing Robots</a></p><h4>Tenha paciência.</h4><p>Se é a primeira vez que você está dando a devida atenção aos testes, você vai achar que eles tomam muito tempo de desenvolvimento. Mas é o começo, todo começo é difícil. Seus testes vão falhar aparentemente sem explicação nenhuma, você vai descobrir que não é possível testar tudo somente com o Espresso (como foi o caso das RuntimePermissions), entre outros problemas que irão te fazer querer desistir. Mas não desista, depois que você pega a prática, as coisas fluem melhor. Você passa a perceber algumas coisas, como:</p><ul><li>Começa a desenvolver pensando em como você vai testar aquele código;</li><li>Se sente mais seguro ao fazer uma grande alteração no código, pois sabe que os seus testes estarão te cobrindo, caso você quebre algo;</li><li>Passa a estimar suas tarefas já pensando no esforço dos testes.</li></ul><p>É muito importante ter uma cultura de teste, seja com Espresso ou não, seja um app mobile ou não. Fiz esta série de posts pensando em incentivar os desenvolvedores a criar este hábito, tratar os testes como aliados e não como inimigos.</p><h4>Obrigado!</h4><p>Espero que tenha gostado do conteúdo que compartilhei ao longo destes posts. Se tiver alguma dúvida, sugestão ou crítica, fique à vontade para me procurar.</p><p>Abraço!</p><p>heitorcolangelo@gmail.com</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dee47be84571" width="1" height="1" alt="">
